<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>compost on sytzez</title>
    <link>https://sytzez.com/tags/compost/</link>
    <description>Recent content in compost on sytzez</description>
    <image>
      <url>https://sytzez.com/papermod-cover.png</url>
      <link>https://sytzez.com/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 27 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://sytzez.com/tags/compost/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/</guid>
      <description>I&amp;rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.
Structure of a Compiler Before embarking on this journey, I did some research on how compilers normally work.</description>
    </item>
    
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 2: Syntactic Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/</guid>
      <description>In the previous post, I described how I implemented lexical analysis for Compost. The next phase in compilation is syntactic analysis, which turns the string of tokens into an &amp;lsquo;abstract syntax tree&amp;rsquo;. It also throws meaningful errors when wrong syntax is used.
The Abstract Syntax Tree An abstract syntax tree (AST) represents the code at the level of statements and expressions. Every type of statement and expression has its own data structure, which can contain other statements or expressions, forming a tree of data structures.</description>
    </item>
    
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/</guid>
      <description>In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn&amp;rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.
To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program.</description>
    </item>
    
    <item>
      <title>Sketch for a new programming language: Part 2</title>
      <link>https://sytzez.com/blog/sketch-for-a-new-programming-language-2/</link>
      <pubDate>Sun, 16 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/sketch-for-a-new-programming-language-2/</guid>
      <description>A solution to inheritance I&amp;rsquo;ve had some more thought about my programming language &amp;ldquo;Compost&amp;rdquo;. It might have its own solution to the old problems of object oriented programming, mainly class inheritance.
One of the problems class inheritance tries to solve is code reuse between classes. In OOP, you&amp;rsquo;d solve this by creating a superclass which contains the methods which are shared between classes. The classes that use those method then need to inheritd from that super class.</description>
    </item>
    
    <item>
      <title>Sketch for a new programming language</title>
      <link>https://sytzez.com/blog/sketch-for-a-new-programming-language/</link>
      <pubDate>Thu, 13 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/sketch-for-a-new-programming-language/</guid>
      <description>I&amp;rsquo;m coming up with the spec of a new programming language. Working title: &amp;ldquo;Compost&amp;rdquo;. Don&amp;rsquo;t worry, it&amp;rsquo;s just for fun. For now this is just a first sketch of the ideas I had today. They are subject to change.
The main idea of the language is ultimate composability and recomposability. It forces the programmer to think in terms of the minimum amount of dependencies required for each part of the code, and makes each part as reusable as possible.</description>
    </item>
    
  </channel>
</rss>
