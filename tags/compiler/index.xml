<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>compiler on sytzez</title>
    <link>https://sytzez.com/tags/compiler/</link>
    <description>Recent content in compiler on sytzez</description>
    <image>
      <url>https://sytzez.com/papermod-cover.png</url>
      <link>https://sytzez.com/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 27 Nov 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://sytzez.com/tags/compiler/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/</guid>
      <description>I&amp;rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.
Structure of a Compiler Before embarking on this journey, I did some research on how compilers normally work.</description>
    </item>
    
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 2: Syntactic Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/</guid>
      <description>In the previous post, I described how I implemented lexical analysis for Compost. The next phase in compilation is syntactic analysis, which turns the string of tokens into an &amp;lsquo;abstract syntax tree&amp;rsquo;. It also throws meaningful errors when wrong syntax is used.
The Abstract Syntax Tree An abstract syntax tree (AST) represents the code at the level of statements and expressions. Every type of statement and expression has its own data structure, which can contain other statements or expressions, forming a tree of data structures.</description>
    </item>
    
    <item>
      <title>Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis</title>
      <link>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/</guid>
      <description>In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn&amp;rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.
To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program.</description>
    </item>
    
  </channel>
</rss>
