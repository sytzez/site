<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis | sytzez</title><meta name=keywords content="programming,compost,rust,compiler"><meta name=description content="I&rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.
Structure of a Compiler Before embarking on this journey, I did some research on how compilers normally work."><meta name=author content="sytzez"><link rel=canonical href=https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.cda683eb656d98f5c337fca22f1c0b0b8e2c358cf12c7681456128ef95986432.css integrity="sha256-zaaD62VtmPXDN/yiLxwLC44sNYzxLHaBRWEo75WYZDI=" rel="preload stylesheet" as=style><link rel=icon href=https://sytzez.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sytzez.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sytzez.com/favicon-32x32.png><link rel=apple-touch-icon href=https://sytzez.com/apple-touch-icon.png><link rel=mask-icon href=https://sytzez.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis"><meta property="og:description" content="I&rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.
Structure of a Compiler Before embarking on this journey, I did some research on how compilers normally work."><meta property="og:type" content="article"><meta property="og:url" content="https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/"><meta property="og:image" content="https://sytzez.com/papermod-cover.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-27T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sytzez.com/papermod-cover.png"><meta name=twitter:title content="Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis"><meta name=twitter:description content="I&rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.
Structure of a Compiler Before embarking on this journey, I did some research on how compilers normally work."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://sytzez.com/blog/"},{"@type":"ListItem","position":2,"name":"Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis","item":"https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis","name":"Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis","description":"I\u0026rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.\nStructure of a Compiler Before embarking on this journey, I did some research on how compilers normally work.","keywords":["programming","compost","rust","compiler"],"articleBody":"I’ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago. The repository for it can be found on GitHub and there is also a playground available where you can try out the language. This is the first part of a series of blogs detailing my experience of writing my first compiler.\nStructure of a Compiler Before embarking on this journey, I did some research on how compilers normally work. Almost all sources described these phases that a compiler goes through:\nLexical Analysis or Tokenization Syntactic Analysis or Parsing Semantic Analysis Intermediate Code Generation Code Optimization Binary Code Generation So far, I’ve implemented the first three steps in the compiler, and added a different fourth step: Running the Code and Displaying the Result.\nBecause the Compost language currently doesn’t support any type of input, the result of a program will always be the same. In a sense, each program can be optimized into a single constant, which is then output to the console. For this reason, it doesn’t make a lot of sense to compile into a binary at this point. The compiler just outputs the constant result for now.\nHowever, I am planning to add input methods to the language in the future, which will make it worth to implement the remaining three steps of compilation. For the last two steps I’m planning to use LLVM, which will hopefully make that part a lot less painful.\nLexical Analysis In this post I will focus on how I implemented the first phase of compilation in Rust. Lexical Analysis, or Tokenization, is the process of grouping characters of the code into a sequence of ’tokens’, which are the smallest meaningful units code can be broken up into. It will also throw meaningful errors when there is an unexpected character.\nRust’s enums are ideal for representing tokens. This is the Token enum of my compiler as of writing this article:\npub enum Token { Down(Level), Up(Level), Next(Next), Eof, Kw(Kw), Local(String), Global(String), Op(Op), Lit(Lit), Space, } The types Level, Next, Kw (Keyword), Op (Operator) and Lit (Literal) are also Rust enums. Example:\npub enum Kw { Mod, Class, Struct, Traits, Defs, Lets, Zelf, } To read tokens from a string, I’ve written the next_token functions. It returns the next token, and the amount of characters that token spans.\ntype SizedToken = (Option\u003cToken\u003e, usize); pub fn next_token(code: \u0026str) -\u003e Result\u003cSizedToken, ErrorMessage\u003e { let char = match code.chars().next() { Some(c) =\u003e c, None =\u003e return Ok((Some(Token::Eof), 1)), }; let token = match char { ' ' =\u003e (Some(Token::Space), 1), '#' =\u003e (None, comment_size(code)), '(' =\u003e (Some(Token::Down(Level::Paren)), 1), ')' =\u003e (Some(Token::Up(Level::Paren)), 1), ':' =\u003e (Some(Token::Down(Level::Colon)), 1), '\\n' | '\\r' =\u003e (Some(Token::Next(Next::Line)), 1), ',' =\u003e (Some(Token::Next(Next::Comma)), 1), '+' =\u003e (Some(Token::Op(Op::Add)), 1), // ... 'a'..='z' =\u003e next_local_token(code), 'A'..='Z' | '\\\\' =\u003e next_global_token(code), '0'..='9' =\u003e next_number_token(code), '\\'' =\u003e next_string_token(code), _ =\u003e return Err(ErrorMessage::UnexpectedChar(char.to_string())), }; Ok(token) } Based on the first character, it either returns a simple token with size 1, or it uses other functions to continue to read more complex tokens. ErrorMessage is another enum which is used for errors across the compiler.\nAll of the code above can be found here.\nLevels in Compost Down, Up and Next are features of Compost’s syntax. Compost uses levels to organise its code. Look at this Compost code:\nmod ModuleA class x Int y Int mod ModuleB class x: Int y: Int mod ModuleC class(x: Int, y: Int) All three modules are semantically the same. The only difference is the levels syntax they use.\nThe three ways of organising code into levels are:\nIndentation. The more indented something is, the deeper the level. Using colons (:). Code on the same line after the colon is on a deeper level. After a comma (,) the code is on the original level again. Using parentheses (( and )). Code within parentheses is on a deeper level. During tokenization, each Token is assigned a level based on these three syntaxes. The type for a Token with a level is a simple tuple:\npub type LeveledToken = (Token, usize); To keep track of the level while tokenizing, I’ve created a utility struct called LevelStack.\n/// The type of level syntax. pub enum Level { Colon, Paren, } /// Used to separate levels. pub enum Next { Comma, Line, } /// Utility to keep track of the depth level of our code. struct LevelStack { // The current stack of Colon and Parentheses levels. levels: Vec\u003cLevel\u003e, // The current indentation level. indentation: usize, } impl LevelStack { fn new() -\u003e Self { LevelStack { levels: vec![], indentation: 0, } } /// Go deeper. fn push(\u0026mut self, level: Level) { self.levels.push(level) } /// Go up to a specific type of Level. fn pop(\u0026mut self, level: \u0026Level) { if let Some(popped_level) = self.levels.pop() { match level { Level::Paren =\u003e { // Keep popping until we're at an opening parenthesis. if popped_level != Level::Paren { self.pop(level) } } Level::Colon =\u003e { // If the last level wasn't a colon, push it back. if popped_level != Level::Colon { self.push(popped_level) } } } } } /// Add one indentation level. fn indent(\u0026mut self) { self.indentation += 1 } /// Process a 'Next' token. fn next(\u0026mut self, next: \u0026Next) { match next { Next::Line =\u003e { // Clear all colon levels. self.levels.retain(|level| level != \u0026Level::Colon); // Reset indentation. self.indentation = 0; } // Go back to the latest Colon level when encountering a comma. Next::Comma =\u003e self.pop(\u0026Level::Colon), } } /// Gets the current level. fn level(\u0026self) -\u003e usize { self.levels.len() + self.indentation } } The full code can be found here.\nThe Tokenize Function All of the functionality described above comes together in the tokenize function. It takes a string of raw code and returns the leveled tokens.\npub fn tokenize(code: \u0026str) -\u003e Tokens { let mut position: usize = 0; let mut level_stack = LevelStack::new(); let mut leveled_tokens: Vec\u003cLeveledToken\u003e = vec![]; let mut is_beginning_of_line = true; while position \u003c= code.len() { // Use the next_token function to get the next token. let sized_token = match next_token(\u0026code[position..]) { Ok(sized_token) =\u003e sized_token, Err(message) =\u003e // ... pass on the error }; // Move forward the position we are at in the code. position += sized_token.1; if let Some(token) = sized_token.0 { // Check if we are still at the beginning of a line. // Spaces at the beginning are not regarded as 'the line', but as markers for indentation. is_beginning_of_line = is_beginning_of_line \u0026\u0026 token == Token::Space; match token { // Add indentation if we have another space at the beginning of the line. Token::Space =\u003e if is_beginning_of_line { level_stack.indent() } // Push or pop levels according to the received tokens. Token::Down(level) =\u003e level_stack.push(level), Token::Up(level) =\u003e level_stack.pop(\u0026level), Token::Next(next) =\u003e { level_stack.next(\u0026next); if next == Next::Line { is_beginning_of_line = true } } Token::Eof =\u003e leveled_tokens.push((Token::Eof, 0)), // Any other tokens are regular tokens without anything to do with our levels. // We simply add them to our vector of tokens at the current level. _ =\u003e leveled_tokens.push((token, level_stack.level())), } } } leveled_tokens.into() } This code is available here.\nThe ‘Tokens’ Utility Struct As you might have noticed, the output type of the tokenize function is Tokens. This is another utility struct which facilitates traversing the tokens in the next phase: Syntactic Analysis.\n/// Provides utility functions that help traversing the tokens. pub struct Tokens { tokens: Vec\u003cLeveledToken\u003e, position: usize, } impl Tokens { /// Advance to the next token. pub fn step(\u0026mut self) { self.position += 1; } /// Whether there are more tokens left. pub fn still_more(\u0026self) -\u003e bool { self.position \u003c self.tokens.len() } /// Whether the current token is deeper than the given level. pub fn deeper_than(\u0026self, level: usize) -\u003e bool { self.still_more() \u0026\u0026 self.level() \u003e level } pub fn deeper_than_or_eq(\u0026self, level: usize) -\u003e bool { self.still_more() \u0026\u0026 self.level() \u003e= level } /// The remaining tokens. pub fn remaining(\u0026self) -\u003e \u0026[LeveledToken] { \u0026self.tokens[self.position..] } /// The current token. pub fn token(\u0026self) -\u003e \u0026Token { \u0026self.tokens[self.position].0 } /// The current level. pub fn level(\u0026self) -\u003e usize { self.tokens[self.position].1 } } The source of this struct is in this file.\nConclusion Tokenization is probably the most straightforward part of compilation. By linearly traversing the characters of the code we get a vector of tokens. Rust’s enum type is ideal for representing tokens. Using enums will come in handy at later phases because we can use match statements to decide what happens when a token is encountered.\nThe most complex part of this phase was adding ’levels’, which is a unique feature of the Compost language that provides multiple syntaxes for organising the code.\nIf you are curious to see how I turn these tokens into an abstract syntax tree, read Part 2: Syntactic Analysis.\n","wordCount":"1460","inLanguage":"en","datePublished":"2022-11-27T00:00:00Z","dateModified":"2022-11-27T00:00:00Z","author":{"@type":"Person","name":"sytzez"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-1-lexical-analysis/"},"publisher":{"@type":"Organization","name":"sytzez","logo":{"@type":"ImageObject","url":"https://sytzez.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sytzez.com/ accesskey=h title="sytzez (Alt + H)">sytzez</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sytzez.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://sytzez.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/sytzez title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sytzez.com/>Home</a>&nbsp;»&nbsp;<a href=https://sytzez.com/blog/>Blogs</a></div><h1 class=post-title>Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis</h1><div class=post-meta><span title='2022-11-27 00:00:00 +0000 UTC'>November 27, 2022</span>&nbsp;·&nbsp;7 min&nbsp;·&nbsp;sytzez</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#structure-of-a-compiler aria-label="Structure of a Compiler">Structure of a Compiler</a></li><li><a href=#lexical-analysis aria-label="Lexical Analysis">Lexical Analysis</a></li><li><a href=#levels-in-compost aria-label="Levels in Compost">Levels in Compost</a></li><li><a href=#the-tokenize-function aria-label="The Tokenize Function">The Tokenize Function</a></li><li><a href=#the-tokens-utility-struct aria-label="The &amp;lsquo;Tokens&amp;rsquo; Utility Struct">The &lsquo;Tokens&rsquo; Utility Struct</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>I&rsquo;ve set out to write a compiler for Compost, the experimental programming language I came up with about a month ago.
The repository for it can be found <a href=https://github.com/sytzez/compost>on GitHub</a> and there is also a <a href=http://compost-playground.sytzez.com>playground</a> available where you can try out the language.
This is the first part of a series of blogs detailing my experience of writing my first compiler.</p><h1 id=structure-of-a-compiler>Structure of a Compiler<a hidden class=anchor aria-hidden=true href=#structure-of-a-compiler>#</a></h1><p>Before embarking on this journey, I did some research on how compilers normally work. Almost all sources described these phases that a compiler goes through:</p><ul><li><strong>Lexical Analysis</strong> or <strong>Tokenization</strong></li><li><strong>Syntactic Analysis</strong> or <strong>Parsing</strong></li><li><strong>Semantic Analysis</strong></li><li><strong>Intermediate Code Generation</strong></li><li><strong>Code Optimization</strong></li><li><strong>Binary Code Generation</strong></li></ul><p>So far, I&rsquo;ve implemented the first three steps in the compiler, and added a different fourth step: Running the Code and Displaying the Result.</p><p>Because the Compost language currently doesn&rsquo;t support any type of input, the result of a program will always be the same. In a sense, each program can be optimized into a single constant, which is then output to the console.
For this reason, it doesn&rsquo;t make a lot of sense to compile into a binary at this point. The compiler just outputs the constant result for now.</p><p>However, I am planning to add input methods to the language in the future, which will make it worth to implement the remaining three steps of compilation. For the last two steps I&rsquo;m planning to use LLVM, which will hopefully make that part a lot less painful.</p><h1 id=lexical-analysis>Lexical Analysis<a hidden class=anchor aria-hidden=true href=#lexical-analysis>#</a></h1><p>In this post I will focus on how I implemented the first phase of compilation in Rust. Lexical Analysis, or Tokenization, is the process of grouping characters of the code into a sequence of &rsquo;tokens&rsquo;, which are the smallest meaningful units code can be broken up into. It will also throw meaningful errors when there is an unexpected character.</p><p>Rust&rsquo;s enums are ideal for representing tokens. This is the <code>Token</code> enum of my compiler as of writing this article:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Down</span><span class=p>(</span><span class=n>Level</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Up</span><span class=p>(</span><span class=n>Level</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Next</span><span class=p>(</span><span class=n>Next</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Eof</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Kw</span><span class=p>(</span><span class=n>Kw</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Local</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Global</span><span class=p>(</span><span class=nb>String</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Op</span><span class=p>(</span><span class=n>Op</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Lit</span><span class=p>(</span><span class=n>Lit</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Space</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>The types <code>Level</code>, <code>Next</code>, <code>Kw</code> (Keyword), <code>Op</code> (Operator) and <code>Lit</code> (Literal) are also Rust enums. Example:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Kw</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Mod</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Class</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Struct</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Traits</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Defs</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Lets</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Zelf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>To read tokens from a string, I&rsquo;ve written the <code>next_token</code> functions. It returns the next token, and the amount of characters that token spans.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>type</span> <span class=nc>SizedToken</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=nb>Option</span><span class=o>&lt;</span><span class=n>Token</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>next_token</span><span class=p>(</span><span class=n>code</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nb>Result</span><span class=o>&lt;</span><span class=n>SizedToken</span><span class=p>,</span><span class=w> </span><span class=n>ErrorMessage</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>code</span><span class=p>.</span><span class=n>chars</span><span class=p>().</span><span class=n>next</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>Some</span><span class=p>(</span><span class=n>c</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>c</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nb>None</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>((</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Eof</span><span class=p>),</span><span class=w> </span><span class=mi>1</span><span class=p>)),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=kt>char</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39; &#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Space</span><span class=p>),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;#&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>None</span><span class=p>,</span><span class=w> </span><span class=n>comment_size</span><span class=p>(</span><span class=n>code</span><span class=p>)),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;(&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Down</span><span class=p>(</span><span class=n>Level</span>::<span class=n>Paren</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;)&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Up</span><span class=p>(</span><span class=n>Level</span>::<span class=n>Paren</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;:&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Down</span><span class=p>(</span><span class=n>Level</span>::<span class=n>Colon</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;\n&#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;\r&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Next</span><span class=p>(</span><span class=n>Next</span>::<span class=n>Line</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;,&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Next</span><span class=p>(</span><span class=n>Next</span>::<span class=n>Comma</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;+&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>(</span><span class=nb>Some</span><span class=p>(</span><span class=n>Token</span>::<span class=n>Op</span><span class=p>(</span><span class=n>Op</span>::<span class=n>Add</span><span class=p>)),</span><span class=w> </span><span class=mi>1</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=sc>&#39;a&#39;</span><span class=o>..=</span><span class=sc>&#39;z&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>next_local_token</span><span class=p>(</span><span class=n>code</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;A&#39;</span><span class=o>..=</span><span class=sc>&#39;Z&#39;</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=sc>&#39;\\&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>next_global_token</span><span class=p>(</span><span class=n>code</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;0&#39;</span><span class=o>..=</span><span class=sc>&#39;9&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>next_number_token</span><span class=p>(</span><span class=n>code</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=sc>&#39;\&#39;&#39;</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>next_string_token</span><span class=p>(</span><span class=n>code</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>return</span><span class=w> </span><span class=nb>Err</span><span class=p>(</span><span class=n>ErrorMessage</span>::<span class=n>UnexpectedChar</span><span class=p>(</span><span class=kt>char</span><span class=p>.</span><span class=n>to_string</span><span class=p>())),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nb>Ok</span><span class=p>(</span><span class=n>token</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>Based on the first character, it either returns a simple token with size 1, or it uses other functions to continue to read more complex tokens.
<code>ErrorMessage</code> is another enum which is used for errors across the compiler.</p><p>All of the code above can be found <a href=https://github.com/sytzez/compost/blob/master/src/lex/token.rs>here</a>.</p><h1 id=levels-in-compost>Levels in Compost<a hidden class=anchor aria-hidden=true href=#levels-in-compost>#</a></h1><p><code>Down</code>, <code>Up</code> and <code>Next</code> are features of Compost&rsquo;s syntax. Compost uses levels to organise its code. Look at this Compost code:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=n>mod</span> <span class=no>ModuleA</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span>
</span></span><span class=line><span class=cl>        <span class=n>x</span>
</span></span><span class=line><span class=cl>            <span class=no>Int</span>
</span></span><span class=line><span class=cl>        <span class=n>y</span>
</span></span><span class=line><span class=cl>            <span class=no>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mod</span> <span class=no>ModuleB</span>
</span></span><span class=line><span class=cl>    <span class=k>class</span>
</span></span><span class=line><span class=cl>        <span class=ss>x</span><span class=p>:</span> <span class=no>Int</span>
</span></span><span class=line><span class=cl>        <span class=ss>y</span><span class=p>:</span> <span class=no>Int</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>mod</span> <span class=no>ModuleC</span>
</span></span><span class=line><span class=cl>    <span class=n>class</span><span class=p>(</span><span class=ss>x</span><span class=p>:</span> <span class=no>Int</span><span class=p>,</span> <span class=ss>y</span><span class=p>:</span> <span class=no>Int</span><span class=p>)</span></span></span></code></pre></div><p>All three modules are semantically the same. The only difference is the levels syntax they use.</p><p>The three ways of organising code into levels are:</p><ul><li>Indentation. The more indented something is, the deeper the level.</li><li>Using colons (<code>:</code>). Code on the same line after the colon is on a deeper level. After a comma (<code>,</code>) the code is on the original level again.</li><li>Using parentheses (<code>(</code> and <code>)</code>). Code within parentheses is on a deeper level.</li></ul><p>During tokenization, each <code>Token</code> is assigned a level based on these three syntaxes. The type for a Token with a level is a simple tuple:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>type</span> <span class=nc>LeveledToken</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>(</span><span class=n>Token</span><span class=p>,</span><span class=w> </span><span class=kt>usize</span><span class=p>);</span></span></span></code></pre></div><p>To keep track of the level while tokenizing, I&rsquo;ve created a utility struct called <code>LevelStack</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// The type of level syntax.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Level</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Colon</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Paren</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Used to separate levels.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>enum</span> <span class=nc>Next</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Comma</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Line</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=sd>/// Utility to keep track of the depth level of our code.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>struct</span> <span class=nc>LevelStack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The current stack of Colon and Parentheses levels.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>levels</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>Level</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The current indentation level.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>indentation</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>LevelStack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>fn</span> <span class=nf>new</span><span class=p>()</span><span class=w> </span>-&gt; <span class=nc>Self</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>LevelStack</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>levels</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>indentation</span>: <span class=mi>0</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Go deeper.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>push</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>level</span>: <span class=nc>Level</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>levels</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>level</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Go up to a specific type of Level.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>level</span>: <span class=kp>&amp;</span><span class=nc>Level</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>popped_level</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>levels</span><span class=p>.</span><span class=n>pop</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>level</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Level</span>::<span class=n>Paren</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// Keep popping until we&#39;re at an opening parenthesis.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=n>popped_level</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>Level</span>::<span class=n>Paren</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=n>level</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Level</span>::<span class=n>Colon</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=c1>// If the last level wasn&#39;t a colon, push it back.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=n>popped_level</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=n>Level</span>::<span class=n>Colon</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                        </span><span class=bp>self</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>popped_level</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Add one indentation level.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>indent</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>indentation</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Process a &#39;Next&#39; token.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>next</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>next</span>: <span class=kp>&amp;</span><span class=nc>Next</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>match</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>Next</span>::<span class=n>Line</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Clear all colon levels.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>levels</span><span class=p>.</span><span class=n>retain</span><span class=p>(</span><span class=o>|</span><span class=n>level</span><span class=o>|</span><span class=w> </span><span class=n>level</span><span class=w> </span><span class=o>!=</span><span class=w> </span><span class=o>&amp;</span><span class=n>Level</span>::<span class=n>Colon</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Reset indentation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=bp>self</span><span class=p>.</span><span class=n>indentation</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Go back to the latest Colon level when encountering a comma.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=n>Next</span>::<span class=n>Comma</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=n>Level</span>::<span class=n>Colon</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Gets the current level.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>fn</span> <span class=nf>level</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>levels</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>+</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>indentation</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>The full code can be found <a href=https://github.com/sytzez/compost/blob/master/src/lex/tokenizer.rs>here</a>.</p><h1 id=the-tokenize-function>The Tokenize Function<a hidden class=anchor aria-hidden=true href=#the-tokenize-function>#</a></h1><p>All of the functionality described above comes together in the <code>tokenize</code> function. It takes a string of raw code and returns the leveled tokens.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>tokenize</span><span class=p>(</span><span class=n>code</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>Tokens</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>position</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>level_stack</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>LevelStack</span>::<span class=n>new</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>leveled_tokens</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>LeveledToken</span><span class=o>&gt;</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>is_beginning_of_line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>while</span><span class=w> </span><span class=n>position</span><span class=w> </span><span class=o>&lt;=</span><span class=w> </span><span class=n>code</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Use the next_token function to get the next token.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>sized_token</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=k>match</span><span class=w> </span><span class=n>next_token</span><span class=p>(</span><span class=o>&amp;</span><span class=n>code</span><span class=p>[</span><span class=n>position</span><span class=o>..</span><span class=p>])</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Ok</span><span class=p>(</span><span class=n>sized_token</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>sized_token</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nb>Err</span><span class=p>(</span><span class=n>message</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=c1>// ... pass on the error
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Move forward the position we are at in the code.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>position</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=n>sized_token</span><span class=p>.</span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>token</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>sized_token</span><span class=p>.</span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=c1>// Check if we are still at the beginning of a line. 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=c1>// Spaces at the beginning are not regarded as &#39;the line&#39;, but as markers for indentation.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>            </span><span class=n>is_beginning_of_line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>is_beginning_of_line</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Token</span>::<span class=n>Space</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>match</span><span class=w> </span><span class=n>token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Add indentation if we have another space at the beginning of the line.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=n>Token</span>::<span class=n>Space</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>is_beginning_of_line</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>level_stack</span><span class=p>.</span><span class=n>indent</span><span class=p>()</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Push or pop levels according to the received tokens.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=n>Token</span>::<span class=n>Down</span><span class=p>(</span><span class=n>level</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>level_stack</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>level</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Up</span><span class=p>(</span><span class=n>level</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>level_stack</span><span class=p>.</span><span class=n>pop</span><span class=p>(</span><span class=o>&amp;</span><span class=n>level</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Next</span><span class=p>(</span><span class=n>next</span><span class=p>)</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>level_stack</span><span class=p>.</span><span class=n>next</span><span class=p>(</span><span class=o>&amp;</span><span class=n>next</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>if</span><span class=w> </span><span class=n>next</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>Next</span>::<span class=n>Line</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>is_beginning_of_line</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=kc>true</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>Token</span>::<span class=n>Eof</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>leveled_tokens</span><span class=p>.</span><span class=n>push</span><span class=p>((</span><span class=n>Token</span>::<span class=n>Eof</span><span class=p>,</span><span class=w> </span><span class=mi>0</span><span class=p>)),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Any other tokens are regular tokens without anything to do with our levels.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=c1>// We simply add them to our vector of tokens at the current level.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=n>_</span><span class=w> </span><span class=o>=&gt;</span><span class=w> </span><span class=n>leveled_tokens</span><span class=p>.</span><span class=n>push</span><span class=p>((</span><span class=n>token</span><span class=p>,</span><span class=w> </span><span class=n>level_stack</span><span class=p>.</span><span class=n>level</span><span class=p>())),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>leveled_tokens</span><span class=p>.</span><span class=n>into</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>This code is available <a href=https://github.com/sytzez/compost/blob/master/src/lex/tokenizer.rs>here</a>.</p><h1 id=the-tokens-utility-struct>The &lsquo;Tokens&rsquo; Utility Struct<a hidden class=anchor aria-hidden=true href=#the-tokens-utility-struct>#</a></h1><p>As you might have noticed, the output type of the <code>tokenize</code> function is <code>Tokens</code>. This is another utility struct which facilitates traversing the tokens in the next phase: Syntactic Analysis.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Provides utility functions that help traversing the tokens.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Tokens</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>tokens</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=n>LeveledToken</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>position</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>impl</span><span class=w> </span><span class=n>Tokens</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Advance to the next token.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>step</span><span class=p>(</span><span class=o>&amp;</span><span class=k>mut</span><span class=w> </span><span class=bp>self</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Whether there are more tokens left.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>still_more</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=w> </span><span class=o>&lt;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>tokens</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// Whether the current token is deeper than the given level.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>deeper_than</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>level</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>still_more</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>level</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>level</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>deeper_than_or_eq</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>level</span>: <span class=kt>usize</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>bool</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>still_more</span><span class=p>()</span><span class=w> </span><span class=o>&amp;&amp;</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>level</span><span class=p>()</span><span class=w> </span><span class=o>&gt;=</span><span class=w> </span><span class=n>level</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// The remaining tokens.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>remaining</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=p>[</span><span class=n>LeveledToken</span><span class=p>]</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>tokens</span><span class=p>[</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=o>..</span><span class=p>]</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// The current token.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>token</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=nc>Token</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=o>&amp;</span><span class=bp>self</span><span class=p>.</span><span class=n>tokens</span><span class=p>[</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=p>].</span><span class=mi>0</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=sd>/// The current level.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>level</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kt>usize</span> <span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>tokens</span><span class=p>[</span><span class=bp>self</span><span class=p>.</span><span class=n>position</span><span class=p>].</span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>The source of this struct is in <a href=https://github.com/sytzez/compost/blob/master/src/lex/tokens.rs>this file</a>.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Tokenization is probably the most straightforward part of compilation. By linearly traversing the characters of the code we get a vector of tokens.
Rust&rsquo;s enum type is ideal for representing tokens. Using enums will come in handy at later phases because we can use <code>match</code> statements to decide what happens when a token is encountered.</p><p>The most complex part of this phase was adding &rsquo;levels&rsquo;, which is a unique feature of the Compost language that provides multiple syntaxes for organising the code.</p><p>If you are curious to see how I turn these tokens into an abstract syntax tree, read <a href=/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/>Part 2: Syntactic Analysis</a>.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sytzez.com/tags/programming/>programming</a></li><li><a href=https://sytzez.com/tags/compost/>compost</a></li><li><a href=https://sytzez.com/tags/rust/>rust</a></li><li><a href=https://sytzez.com/tags/compiler/>compiler</a></li></ul><nav class=paginav><a class=prev href=https://sytzez.com/blog/analysing-the-first-page-of-bachs-french-ouverture/><span class=title>« Prev</span><br><span>Analysing the first page of Bach's French Ouverture BWV 831</span></a>
<a class=next href=https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/><span class=title>Next »</span><br><span>Creating a Compiler for Compost using Rust, Part 2: Syntactic Analysis</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on twitter" href="https://twitter.com/intent/tweet/?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f&hashtags=programming%2ccompost%2crust%2ccompiler"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f&title=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis&summary=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis&source=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f&title=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on whatsapp" href="https://api.whatsapp.com/send?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis%20-%20https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 1: Lexical Analysis on telegram" href="https://telegram.me/share/url?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%201%3a%20Lexical%20Analysis&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-1-lexical-analysis%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://sytzez.com/>sytzez</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script id=mermaid-script async src=https://cdn.jsdelivr.net/npm/mermaid@9.1.7/dist/mermaid.min.js></script>
<script>document.getElementById("mermaid-script").addEventListener("load",()=>{mermaid.initialize({startOnLoad:!0,theme:"neutral"})})</script><script id=osmd-script async src=https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.5.7/build/opensheetmusicdisplay.min.js></script>
<script>(()=>{document.addEventListener("DOMContentLoaded",t),document.getElementById("osmd-script").addEventListener("load",t);let e=!0;function t(){if(e){e=!1;return}document.querySelectorAll(".osmd-container").forEach(e=>{const t=new opensheetmusicdisplay.OpenSheetMusicDisplay(e,{drawingParameters:"compacttight"});t.load(e.dataset.musicXmlSrc).then(()=>{t.render()})})}})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>