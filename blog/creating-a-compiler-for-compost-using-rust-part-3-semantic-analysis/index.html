<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis | sytzez</title><meta name=keywords content="programming,compost,rust,compiler"><meta name=description content="In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn&rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.
To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program."><meta name=author content="sytzez"><link rel=canonical href=https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/><link crossorigin=anonymous href=/assets/css/stylesheet.cda683eb656d98f5c337fca22f1c0b0b8e2c358cf12c7681456128ef95986432.css integrity="sha256-zaaD62VtmPXDN/yiLxwLC44sNYzxLHaBRWEo75WYZDI=" rel="preload stylesheet" as=style><link rel=icon href=https://sytzez.com/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://sytzez.com/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://sytzez.com/favicon-32x32.png><link rel=apple-touch-icon href=https://sytzez.com/apple-touch-icon.png><link rel=mask-icon href=https://sytzez.com/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis"><meta property="og:description" content="In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn&rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.
To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program."><meta property="og:type" content="article"><meta property="og:url" content="https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/"><meta property="og:image" content="https://sytzez.com/papermod-cover.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-27T00:00:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://sytzez.com/papermod-cover.png"><meta name=twitter:title content="Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis"><meta name=twitter:description content="In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn&rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.
To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://sytzez.com/blog/"},{"@type":"ListItem","position":2,"name":"Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis","item":"https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis","name":"Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis","description":"In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn\u0026rsquo;t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.\nTo give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program.","keywords":["programming","compost","rust","compiler"],"articleBody":"In the previous installment of this series, I described how I turned the tokens into an abstract syntax tree (AST). The AST contains all statements, expressions and types of the program, but doesn’t link the together. All the names of variables, modules, traits and functions are simply Rust Strings without any meaning beyond that.\nTo give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program. It can also give some more elaborate error messages if anything in the code doesn’t link up correctly.\nSemantic Analysis Semantic analysis, also known as context sensitive analysis, does many things. In the Compost compiler, this has been the most difficult phase to work out so far.\nFirstly, it generates symbol tables from the code, which store ‘symbols’, the names of things, against real information about the program. There are tables for traits, lets, modules, local variables, etc. Each part of the code that can be represented by a name needs to have a symbol table.\nSecondly, it resolves each place where such a symbol is used to the correct information. This can be context dependent. You can, for example, reference something differently from inside a module by leaving out the module prefix. Inside module Op, you can use Add instead of the full Op\\Add.\nFurthermore, it checks that all types match up. It needs to figure out the output type of each expression, and check if it matches the input type of wherever the expression is being used.\nFinally, it transforms all Expression statement enums into what I called Evaluation enums, which have more complete information. They contain references to the actual functions, constants, traits, structs and classes being referenced, rather than just their names in the form of a String. In the Evaluation form they are almost ready to be evaluated into a result.\nSymbol Tables I created the Table struct to contain all the logic for declaring and resolving symbols. It splits symbols up by the \\ character into a vector of smaller strings, called a path.\nWhen an item is declared, it is added to the items vector in the form of a tuple with the path on one side and a Rc (reference counted pointer) to the item on the right side. Rust’s Rc pointer was a good choice here, because items can be retrieved from the table in many places in the code which can then also pass them on to other places. Using a regular \u0026 reference here would have caused Rust hell.\npub struct Table\u003cT\u003e { // The name of the table, just used for error messages. name: \u0026'static str, // The items inside the table, with the path on the left. items: Vec\u003c(Vec\u003cString\u003e, Rc\u003cT\u003e)\u003e, // The longest path length in the table. Used for the algorithm that resolves symbols. longest_path: usize, } The function that resolves a symbol loops through the items to find a match. First, it tries the shortest possible path in the table that matches the given path. If that fails, it will try longer and longer paths.\nThe function also takes into account the scope from where the table was accessed. First it will try to search within the scope to find a resolution. If that fails, it will try outside of the scope.\n/// Resolves the best match of the given path. /// When \"Add\" and \"Op\\Add\" are available, \"Add\" should resolve to the former. /// In the \"Op\" scope, \"Add\" should resolve to the latter. /// When only \"Op\\Add\" is available, \"Add\" should resolve to that. /// Only when the name is not available inside the scope, global search should be tried. pub fn resolve(\u0026self, name: \u0026str, scope: \u0026str) -\u003e CResult\u003cRc\u003cT\u003e\u003e { // Form the path by combining the scope and the symbol name. // \"Add\" in scope \"Op\" will become \"Op/Add\". let path = [Self::path(scope), Self::path(name)].concat(); // Check shortest paths that match first, then longer ones. for match_len in path.len()..=self.longest_path { for (item_path, item) in self.items.iter() { if item_path.len() == match_len { // Check if the shortened end of the path matches the given path. let start = item_path.len() - path.len(); let shortened_item_path = \u0026item_path[start..]; // Return a Rc to the item on a match. if shortened_item_path == path { return Ok(Rc::clone(item)); } } } } if !scope.is_empty() { // If nothing was found, and the scope is not empty, // try searching everywhere by omitting the scope. self.resolve(name, \"\") } else { // If nothing was found even globally, return an error. error(ErrorMessage::NoResolution(self.name, name.into())) } } The full code for Table can be found here.\nAnalysing the AST The analyse_ast function analyses the whole AST and returns a SemanticContext, which contains all accessible elements of the code within symbol tables.\npub struct SemanticContext { pub traits: Table\u003cRefCell\u003cTrait\u003e\u003e, pub lets: Table\u003cRefCell\u003cLet\u003e\u003e, pub interfaces: Table\u003cRefCell\u003cInterface\u003e\u003e, } While the SemanticContext looks fairly simple. The process to get that result incorporates many steps of analysis over the AST. All items are wrapped into Rust’s RefCell, to allow them to be changed at different steps of analysis.\nStep 1: Populating Trait and Interface Identifiers. The first step is simply populating all traits and interface identifiers that exist in the program. An interface is a type that’s automatically defined for each module, it’s simply a combination of all the traits in that module. Populating the traits and interfaces simply adds records to the right tables with dummy items, to be replaced later:\n// Loop through all modules in the AST. for module in ast.mods.iter() { // Add the identifier for this module's interface. let dummy_interface = context.interfaces.declare(\u0026module.name, RefCell::new(vec![]))?; // Loop through all trait statements in this module. for trait_statement in module.traits.iter() { let name = format!(\"{}\\\\{}\", module.name, trait_statement.name); // Add the identifier for this trait. The trait is connected to the interface of the module, which is needed for the next step. context .traits .declare(\u0026name, RefCell::new(Trait::dummy(\u0026name, \u0026dummy_interface)))?; } // Each module has an eponymous trait. This trait can be used to convert other instances into something of that module's type. // For example, the String module creates a String trait, which can be defined on other modules to turn those into a String. context .traits .declare(\u0026module.name, RefCell::new(Trait::dummy(\u0026module.name, \u0026dummy_interface)))?; } Afterwards, there is a slightly complex process to expand the traits contained in each interface. Because Compost has a feature calles ‘automatic definitions’, some traits are automatically defined on modules which they don’t appear on in the code. This process adds those traits to the interface types of those modules. Sometimes, the process needs to be repeated a few times before everything is included.\n// Fill module interfaces, made up of the module's own traits and def traits from other modules. // By this point, all trait identifiers have been populated. for module in ast.mods.iter() { let mut interface = vec![]; // The module's own traits. for trait_statement in module.traits.iter() { let trayt = context .traits .resolve(\u0026trait_statement.name, \u0026module.name)?; interface.push(trayt); } // Traits added on from other modules through defs. for def in module.defs.iter() { let trayt = context.traits.resolve(\u0026def.name, \u0026module.name)?; interface.push(trayt); } let output = interface_type(\u0026interface); context.interfaces.resolve(\u0026module.name, \"\")?.replace(interface); let eponymous_trait = Trait { full_name: module.name.clone(), interface: context.interfaces.resolve(\u0026module.name, \"\")?, inputs: vec![], output, default_definition: None, }; context .traits .resolve(\u0026module.name, \"\")? .replace(eponymous_trait); } // Add automatic definitions to interfaces. Repeat until stable. loop { let mut added_num_of_traits: usize = 0; for module in ast.mods.iter() { let own_interface = context.interfaces.resolve(\u0026module.name, \"\")?; let mut related_interfaces = vec![]; for def in module.defs.iter() { let trayt = context.traits.resolve(\u0026def.name, \u0026module.name)?; related_interfaces.push(Rc::clone(\u0026trayt.borrow().interface)); } for related_interface in related_interfaces.iter() { for trayt in related_interface.borrow().iter() { if own_interface.borrow().iter().any(|t| t == trayt) { continue; } own_interface.replace_with(|old| { old.push(Rc::clone(trayt)); old.clone() }); added_num_of_traits += 1 } } } if added_num_of_traits == 0 { break } } I must admit this code is not very clear. It can probably be refactored.\nStep 2: Analysing Input and Output Types By this point, all traits and interfaces have been populated. Since Compost types are composed of traits and interfaces, it’s now possible to resolve all types in the program. Types occur in the inputs and outputs of traits, lets and defs. Lets include the constructors of structs and classes.\n// Loop over all global lets, and analyse their types. for let_statement in ast.lets.iter() { let lett = Let::analyse_just_types(let_statement, \u0026context, \"\")?; context .lets .declare(\u0026let_statement.name, RefCell::new(lett))?; } // Loop over all modules. for module in ast.mods.iter() { // Analyse all trait input and output types, and analyse their default definitions. for trait_statement in module.traits.iter() { let trayt = Trait::analyse(trait_statement, module, \u0026context, false)?; context .traits .resolve(\u0026trait_statement.name, \u0026module.name)? .replace(trayt); } // Populate module let identifiers, analyse their types. for let_statement in module.lets.iter() { let name = format!(\"{}\\\\{}\", module.name, let_statement.name); let lett = Let::analyse_just_types(let_statement, \u0026context, \u0026module.name)?; context.lets.declare(\u0026name, RefCell::new(lett))?; } // Populate struct and class constructors and definition identifiers, and analyse their types. if let Some(struct_statement) = \u0026module.strukt { // Just the inputs and output of the constructor. let constructor = Let { inputs: Struct::constructor_inputs(struct_statement), output: interface_type(context.interfaces.resolve(\u0026module.name, \"\")?.borrow().as_ref()), evaluation: Evaluation::Zelf, }; context .lets .declare(\u0026module.name, RefCell::new(constructor))?; } else if module.class.is_some() { // Just the inputs and output of the constructor. let constructor = Let { inputs: Class::constructor_inputs(module, \u0026context)?, output: interface_type(context.interfaces.resolve(\u0026module.name, \"\")?.borrow().as_ref()), evaluation: Evaluation::Zelf, }; context .lets .declare(\u0026module.name, RefCell::new(constructor))?; } } Step 3: Analyse Expressions Now that we have all types, as well as identifiers for all lets, traits and defs, including their input and output types, we can finally analyse the expressions occurring throughout the program. Expressions are part of let and def statements.\n// Analyse global let expressions. for let_statement in ast.lets.iter() { let lett = Let::analyse(let_statement, \u0026context, \"\")?; context.lets.resolve(\u0026let_statement.name, \"\")?.replace(lett); } for module in ast.mods.iter() { // Analyse module let expressions. for let_statement in module.lets.iter() { let lett = Let::analyse(let_statement, \u0026context, \u0026module.name)?; context .lets .resolve(\u0026let_statement.name, \u0026module.name)? .replace(lett); } // Re-analyse traits with default definitions. for trait_statement in module.traits.iter() { let trayt = Trait::analyse(trait_statement, module, \u0026context, true)?; context .traits .resolve(\u0026trait_statement.name, \u0026module.name)? .replace(trayt); } // Analyse struct and class constructor and def expressions. if module.strukt.is_some() { let strukt = Struct::analyse(module, \u0026context)?; context .lets .resolve(\u0026module.name, \"\")? .replace(strukt.constructor()); } else if module.class.is_some() { let class = Class::analyse(module, \u0026context)?; context .lets .resolve(\u0026module.name, \"\")? .replace(class.constructor()); } } Find the full code for analyse_ast here.\nAnalysing Evaluations from Expressions All the *::analyse methods that are used in the analyse_ast function are defined in different places. They analyse Lets, Traits, Modules, Defs, Types and Expressions in detail.\nThe core of these analyses it the Evaluation::analyse method, which take an Expression and analyses everything inside it within the right context, resulting in an Evaluation.\nDuring this analysis, it resolves all the referenced traits and lets, checks that the called traits are callable on the expression they’re called on, and verifies that all input and output types are matching1.\nSome parts of this analysis, especially type checking, are still a work of process as of writing this blog. But the whole thing works well enough to make most programs run!\nFind the source code of it here.\nConclusion The most daunting part of the compiler so far has been semantic analysis. It requires many traversions over the AST to resolve and analysis everything in the right order. First we need to know what types (traits and interfaces) are available, then we need to know what lets we have, and what the input and output types of everything is. Then we can analyse the expressions, and check that all types match up.\nThe resulting SemanticContext struct and its contents are so detailed that they can easily be resolved into a result to be displayed in the console, which is what happens in the runtime module. However, ideally I’d like to write some more modules that turn this SemanticContext into intermediate code, which can then be compiled into an actual binary by LLVM.\nEither way, even without compiling to a binary, I feel pretty satisfied with this compiler, at the moment more of an interpreter. that can parse Compost code and execute it! If you are interested in the Compost programming language please check out the GitHub repository, which contains more information about the language in the README. And also check out the Compost Playground in which you can run Compost code from your browser.\n","wordCount":"2029","inLanguage":"en","datePublished":"2022-11-27T00:00:00Z","dateModified":"2022-11-27T00:00:00Z","author":{"@type":"Person","name":"sytzez"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-3-semantic-analysis/"},"publisher":{"@type":"Organization","name":"sytzez","logo":{"@type":"ImageObject","url":"https://sytzez.com/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://sytzez.com/ accesskey=h title="sytzez (Alt + H)">sytzez</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://sytzez.com/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://sytzez.com/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://github.com/sytzez title=Github><span>Github</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://sytzez.com/>Home</a>&nbsp;»&nbsp;<a href=https://sytzez.com/blog/>Blogs</a></div><h1 class=post-title>Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis</h1><div class=post-meta><span title='2022-11-27 00:00:00 +0000 UTC'>November 27, 2022</span>&nbsp;·&nbsp;10 min&nbsp;·&nbsp;sytzez</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#semantic-analysis aria-label="Semantic Analysis">Semantic Analysis</a></li><li><a href=#symbol-tables aria-label="Symbol Tables">Symbol Tables</a></li><li><a href=#analysing-the-ast aria-label="Analysing the AST">Analysing the AST</a><ul><li><a href=#step-1-populating-trait-and-interface-identifiers aria-label="Step 1: Populating Trait and Interface Identifiers.">Step 1: Populating Trait and Interface Identifiers.</a></li><li><a href=#step-2-analysing-input-and-output-types aria-label="Step 2: Analysing Input and Output Types">Step 2: Analysing Input and Output Types</a></li><li><a href=#step-3-analyse-expressions aria-label="Step 3: Analyse Expressions">Step 3: Analyse Expressions</a></li></ul></li><li><a href=#analysing-evaluations-from-expressions aria-label="Analysing Evaluations from Expressions">Analysing Evaluations from Expressions</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></div></details></div><div class=post-content><p>In the <a href=/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/#expressions>previous installment</a> of this series, I described how I turned the tokens into an abstract syntax tree (AST).
The AST contains all statements, expressions and types of the program, but doesn&rsquo;t link the together.
All the names of variables, modules, traits and functions are simply Rust <code>String</code>s without any meaning beyond that.</p><p>To give meaning to these names we can use semantic analysis, which resolves the names into references to the right piece of information in our program.
It can also give some more elaborate error messages if anything in the code doesn&rsquo;t link up correctly.</p><h1 id=semantic-analysis>Semantic Analysis<a hidden class=anchor aria-hidden=true href=#semantic-analysis>#</a></h1><p>Semantic analysis, also known as context sensitive analysis, does many things. In the Compost compiler, this has been the most difficult phase to work out so far.</p><p>Firstly, it generates symbol tables from the code, which store &lsquo;symbols&rsquo;, the names of things, against real information about the program.
There are tables for traits, lets, modules, local variables, etc. Each part of the code that can be represented by a name needs to have a symbol table.</p><p>Secondly, it resolves each place where such a symbol is used to the correct information. This can be context dependent.
You can, for example, reference something differently from inside a module by leaving out the module prefix. Inside module <code>Op</code>, you can use <code>Add</code> instead of the full <code>Op\Add</code>.</p><p>Furthermore, it checks that all types match up. It needs to figure out the output type of each expression, and check if it matches the input type of wherever the expression is being used.</p><p>Finally, it transforms all <code>Expression</code> statement enums into what I called <code>Evaluation</code> enums, which have more complete information.
They contain references to the actual functions, constants, traits, structs and classes being referenced, rather than just their names in the form of a <code>String</code>.
In the <code>Evaluation</code> form they are almost ready to be evaluated into a result.</p><h1 id=symbol-tables>Symbol Tables<a hidden class=anchor aria-hidden=true href=#symbol-tables>#</a></h1><p>I created the <code>Table</code> struct to contain all the logic for declaring and resolving symbols.
It splits symbols up by the <code>\</code> character into a vector of smaller strings, called a path.</p><p>When an item is declared, it is added to the <code>items</code> vector in the form of a tuple with the path on one side and a <code>Rc</code> (reference counted pointer) to the item on the right side.
Rust&rsquo;s <code>Rc</code> pointer was a good choice here, because items can be retrieved from the table in many places in the code which can then also pass them on to other places.
Using a regular <code>&</code> reference here would have caused Rust hell.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>Table</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The name of the table, just used for error messages.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>name</span>: <span class=kp>&amp;</span><span class=o>&#39;</span><span class=nb>static</span> <span class=kt>str</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The items inside the table, with the path on the left.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>items</span>: <span class=nb>Vec</span><span class=o>&lt;</span><span class=p>(</span><span class=nb>Vec</span><span class=o>&lt;</span><span class=nb>String</span><span class=o>&gt;</span><span class=p>,</span><span class=w> </span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;</span><span class=p>)</span><span class=o>&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The longest path length in the table. Used for the algorithm that resolves symbols.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>longest_path</span>: <span class=kt>usize</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>The function that resolves a symbol loops through the items to find a match.
First, it tries the shortest possible path in the table that matches the given path.
If that fails, it will try longer and longer paths.</p><p>The function also takes into account the scope from where the table was accessed.
First it will try to search within the scope to find a resolution.
If that fails, it will try outside of the scope.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=sd>/// Resolves the best match of the given path.
</span></span></span><span class=line><span class=cl><span class=sd>/// When &#34;Add&#34; and &#34;Op\Add&#34; are available, &#34;Add&#34; should resolve to the former.
</span></span></span><span class=line><span class=cl><span class=sd>/// In the &#34;Op&#34; scope, &#34;Add&#34; should resolve to the latter.
</span></span></span><span class=line><span class=cl><span class=sd>/// When only &#34;Op\Add&#34; is available, &#34;Add&#34; should resolve to that.
</span></span></span><span class=line><span class=cl><span class=sd>/// Only when the name is not available inside the scope, global search should be tried.
</span></span></span><span class=line><span class=cl><span class=sd></span><span class=k>pub</span><span class=w> </span><span class=k>fn</span> <span class=nf>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=bp>self</span><span class=p>,</span><span class=w> </span><span class=n>name</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>scope</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=nc>CResult</span><span class=o>&lt;</span><span class=n>Rc</span><span class=o>&lt;</span><span class=n>T</span><span class=o>&gt;&gt;</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Form the path by combining the scope and the symbol name.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// &#34;Add&#34; in scope &#34;Op&#34; will become &#34;Op/Add&#34;.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=p>[</span><span class=bp>Self</span>::<span class=n>path</span><span class=p>(</span><span class=n>scope</span><span class=p>),</span><span class=w> </span><span class=bp>Self</span>::<span class=n>path</span><span class=p>(</span><span class=n>name</span><span class=p>)].</span><span class=n>concat</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Check shortest paths that match first, then longer ones.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>match_len</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>path</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=o>..=</span><span class=bp>self</span><span class=p>.</span><span class=n>longest_path</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=p>(</span><span class=n>item_path</span><span class=p>,</span><span class=w> </span><span class=n>item</span><span class=p>)</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=bp>self</span><span class=p>.</span><span class=n>items</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>if</span><span class=w> </span><span class=n>item_path</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>match_len</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Check if the shortened end of the path matches the given path.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>start</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>item_path</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>-</span><span class=w> </span><span class=n>path</span><span class=p>.</span><span class=n>len</span><span class=p>();</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=kd>let</span><span class=w> </span><span class=n>shortened_item_path</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>item_path</span><span class=p>[</span><span class=n>start</span><span class=o>..</span><span class=p>];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=c1>// Return a Rc to the item on a match.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>shortened_item_path</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>path</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>return</span><span class=w> </span><span class=nb>Ok</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=n>item</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=o>!</span><span class=n>scope</span><span class=p>.</span><span class=n>is_empty</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// If nothing was found, and the scope is not empty,
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=c1>// try searching everywhere by omitting the scope.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=bp>self</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// If nothing was found even globally, return an error.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>error</span><span class=p>(</span><span class=n>ErrorMessage</span>::<span class=n>NoResolution</span><span class=p>(</span><span class=bp>self</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>name</span><span class=p>.</span><span class=n>into</span><span class=p>()))</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>The full code for <code>Table</code> can be found <a href=https://github.com/sytzez/compost/blob/master/src/sem/table.rs>here</a>.</p><h1 id=analysing-the-ast>Analysing the AST<a hidden class=anchor aria-hidden=true href=#analysing-the-ast>#</a></h1><p>The <code>analyse_ast</code> function analyses the whole AST and returns a <code>SemanticContext</code>, which contains all accessible elements of the code within symbol tables.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=k>pub</span><span class=w> </span><span class=k>struct</span> <span class=nc>SemanticContext</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>traits</span>: <span class=nc>Table</span><span class=o>&lt;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=n>Trait</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>lets</span>: <span class=nc>Table</span><span class=o>&lt;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=n>Let</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>pub</span><span class=w> </span><span class=n>interfaces</span>: <span class=nc>Table</span><span class=o>&lt;</span><span class=n>RefCell</span><span class=o>&lt;</span><span class=n>Interface</span><span class=o>&gt;&gt;</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>While the <code>SemanticContext</code> looks fairly simple. The process to get that result incorporates many steps of analysis over the AST.
All items are wrapped into Rust&rsquo;s <code>RefCell</code>, to allow them to be changed at different steps of analysis.</p><h2 id=step-1-populating-trait-and-interface-identifiers>Step 1: Populating Trait and Interface Identifiers.<a hidden class=anchor aria-hidden=true href=#step-1-populating-trait-and-interface-identifiers>#</a></h2><p>The first step is simply populating all traits and interface identifiers that exist in the program.
An interface is a type that&rsquo;s automatically defined for each module, it&rsquo;s simply a combination of all the traits in that module.
Populating the traits and interfaces simply adds records to the right tables with dummy items, to be replaced later:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Loop through all modules in the AST.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=n>module</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>mods</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Add the identifier for this module&#39;s interface.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>dummy_interface</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=fm>vec!</span><span class=p>[]))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Loop through all trait statements in this module.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>trait_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;{}\\{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>trait_statement</span><span class=p>.</span><span class=n>name</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Add the identifier for this trait. The trait is connected to the interface of the module, which is needed for the next step.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Trait</span>::<span class=n>dummy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>dummy_interface</span><span class=p>)))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Each module has an eponymous trait. This trait can be used to convert other instances into something of that module&#39;s type.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=c1>// For example, the String module creates a String trait, which can be defined on other modules to turn those into a String.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>Trait</span>::<span class=n>dummy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>dummy_interface</span><span class=p>)))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>Afterwards, there is a slightly complex process to expand the traits contained in each interface.
Because Compost has a feature calles &lsquo;automatic definitions&rsquo;, some traits are automatically defined on modules which they don&rsquo;t appear on in the code.
This process adds those traits to the interface types of those modules.
Sometimes, the process needs to be repeated a few times before everything is included.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Fill module interfaces, made up of the module&#39;s own traits and def traits from other modules.
</span></span></span><span class=line><span class=cl><span class=c1>// By this point, all trait identifiers have been populated.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=n>module</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>mods</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>interface</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// The module&#39;s own traits.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>trait_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>trait_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>interface</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>trayt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Traits added on from other modules through defs.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>def</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>defs</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>def</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>interface</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>trayt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>output</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>interface_type</span><span class=p>(</span><span class=o>&amp;</span><span class=n>interface</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>interface</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>eponymous_trait</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Trait</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>full_name</span>: <span class=nc>module</span><span class=p>.</span><span class=n>name</span><span class=p>.</span><span class=n>clone</span><span class=p>(),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>interface</span>: <span class=nc>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>inputs</span>: <span class=nc>vec</span><span class=o>!</span><span class=p>[],</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>output</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>default_definition</span>: <span class=nb>None</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>eponymous_trait</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Add automatic definitions to interfaces. Repeat until stable.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>loop</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>added_num_of_traits</span>: <span class=kt>usize</span> <span class=o>=</span><span class=w> </span><span class=mi>0</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>module</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>mods</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>own_interface</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=n>related_interfaces</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>vec!</span><span class=p>[];</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>def</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>defs</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=kd>let</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>context</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>def</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>related_interfaces</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=o>&amp;</span><span class=n>trayt</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>interface</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>for</span><span class=w> </span><span class=n>related_interface</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>related_interfaces</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=k>for</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>related_interface</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=k>if</span><span class=w> </span><span class=n>own_interface</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>iter</span><span class=p>().</span><span class=n>any</span><span class=p>(</span><span class=o>|</span><span class=n>t</span><span class=o>|</span><span class=w> </span><span class=n>t</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=n>trayt</span><span class=p>)</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=k>continue</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>own_interface</span><span class=p>.</span><span class=n>replace_with</span><span class=p>(</span><span class=o>|</span><span class=n>old</span><span class=o>|</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>old</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>Rc</span>::<span class=n>clone</span><span class=p>(</span><span class=n>trayt</span><span class=p>));</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                    </span><span class=n>old</span><span class=p>.</span><span class=n>clone</span><span class=p>()</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=p>});</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>added_num_of_traits</span><span class=w> </span><span class=o>+=</span><span class=w> </span><span class=mi>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>added_num_of_traits</span><span class=w> </span><span class=o>==</span><span class=w> </span><span class=mi>0</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=k>break</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>I must admit this code is not very clear. It can probably be refactored.</p><h2 id=step-2-analysing-input-and-output-types>Step 2: Analysing Input and Output Types<a hidden class=anchor aria-hidden=true href=#step-2-analysing-input-and-output-types>#</a></h2><p>By this point, all traits and interfaces have been populated.
Since Compost types are composed of traits and interfaces, it&rsquo;s now possible to resolve all types in the program.
Types occur in the inputs and outputs of traits, lets and defs.
Lets include the constructors of structs and classes.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Loop over all global lets, and analyse their types.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=n>let_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>lett</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span>::<span class=n>analyse_just_types</span><span class=p>(</span><span class=n>let_statement</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>let_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>lett</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>// Loop over all modules.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=n>module</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>mods</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Analyse all trait input and output types, and analyse their default definitions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>trait_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Trait</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>trait_statement</span><span class=p>,</span><span class=w> </span><span class=n>module</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=kc>false</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>trait_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>trayt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Populate module let identifiers, analyse their types.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>let_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=fm>format!</span><span class=p>(</span><span class=s>&#34;{}\\{}&#34;</span><span class=p>,</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>let_statement</span><span class=p>.</span><span class=n>name</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>lett</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span>::<span class=n>analyse_just_types</span><span class=p>(</span><span class=n>let_statement</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>lett</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Populate struct and class constructors and definition identifiers, and analyse their types.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=kd>let</span><span class=w> </span><span class=nb>Some</span><span class=p>(</span><span class=n>struct_statement</span><span class=p>)</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>strukt</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Just the inputs and output of the constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>constructor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>inputs</span>: <span class=nc>Struct</span>::<span class=n>constructor_inputs</span><span class=p>(</span><span class=n>struct_statement</span><span class=p>),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span>: <span class=nc>interface_type</span><span class=p>(</span><span class=n>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>as_ref</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>evaluation</span>: <span class=nc>Evaluation</span>::<span class=n>Zelf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>constructor</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>class</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=c1>// Just the inputs and output of the constructor.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>constructor</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>inputs</span>: <span class=nc>Class</span>::<span class=n>constructor_inputs</span><span class=p>(</span><span class=n>module</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>)</span><span class=o>?</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>output</span>: <span class=nc>interface_type</span><span class=p>(</span><span class=n>context</span><span class=p>.</span><span class=n>interfaces</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>borrow</span><span class=p>().</span><span class=n>as_ref</span><span class=p>()),</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=n>evaluation</span>: <span class=nc>Evaluation</span>::<span class=n>Zelf</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=p>};</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>declare</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=n>RefCell</span>::<span class=n>new</span><span class=p>(</span><span class=n>constructor</span><span class=p>))</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><h2 id=step-3-analyse-expressions>Step 3: Analyse Expressions<a hidden class=anchor aria-hidden=true href=#step-3-analyse-expressions>#</a></h2><p>Now that we have all types, as well as identifiers for all lets, traits and defs, including their input and output types,
we can finally analyse the expressions occurring throughout the program.
Expressions are part of let and def statements.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-rust data-lang=rust><span class=line><span class=cl><span class=c1>// Analyse global let expressions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span><span class=w> </span><span class=n>let_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>lett</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>let_statement</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>context</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>let_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>lett</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>for</span><span class=w> </span><span class=n>module</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>ast</span><span class=p>.</span><span class=n>mods</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Analyse module let expressions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>let_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>lets</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>lett</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Let</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>let_statement</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>let_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>lett</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Re-analyse traits with default definitions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>for</span><span class=w> </span><span class=n>trait_statement</span><span class=w> </span><span class=k>in</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>traits</span><span class=p>.</span><span class=n>iter</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>trayt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Trait</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>trait_statement</span><span class=p>,</span><span class=w> </span><span class=n>module</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>,</span><span class=w> </span><span class=kc>true</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>traits</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>trait_statement</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>trayt</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=c1>// Analyse struct and class constructor and def expressions.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=k>if</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>strukt</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>strukt</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Struct</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>module</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>strukt</span><span class=p>.</span><span class=n>constructor</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=k>if</span><span class=w> </span><span class=n>module</span><span class=p>.</span><span class=n>class</span><span class=p>.</span><span class=n>is_some</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>class</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=n>Class</span>::<span class=n>analyse</span><span class=p>(</span><span class=n>module</span><span class=p>,</span><span class=w> </span><span class=o>&amp;</span><span class=n>context</span><span class=p>)</span><span class=o>?</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=n>context</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>lets</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>resolve</span><span class=p>(</span><span class=o>&amp;</span><span class=n>module</span><span class=p>.</span><span class=n>name</span><span class=p>,</span><span class=w> </span><span class=s>&#34;&#34;</span><span class=p>)</span><span class=o>?</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=p>.</span><span class=n>replace</span><span class=p>(</span><span class=n>class</span><span class=p>.</span><span class=n>constructor</span><span class=p>());</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=p>}</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span></span></span></code></pre></div><p>Find the full code for <code>analyse_ast</code> <a href=https://github.com/sytzez/compost/blob/master/src/sem/semantic_analyser.rs>here</a>.</p><h1 id=analysing-evaluations-from-expressions>Analysing Evaluations from Expressions<a hidden class=anchor aria-hidden=true href=#analysing-evaluations-from-expressions>#</a></h1><p>All the <code>*::analyse</code> methods that are used in the <code>analyse_ast</code> function are defined in different places. They analyse Lets, Traits, Modules, Defs, Types and Expressions in detail.</p><p>The core of these analyses it the <code>Evaluation::analyse</code> method, which take an <code>Expression</code> and analyses everything inside it within the right context, resulting in an <code>Evaluation</code>.</p><p>During this analysis, it resolves all the referenced traits and lets, checks that the called traits are callable on the expression they&rsquo;re called on, and verifies that all input and output types are matching1.</p><p>Some parts of this analysis, especially type checking, are still a work of process as of writing this blog. But the whole thing works well enough to make most programs run!</p><p>Find the source code of it <a href=https://github.com/sytzez/compost/blob/master/src/sem/evaluation.rs>here</a>.</p><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>The most daunting part of the compiler so far has been semantic analysis.
It requires many traversions over the AST to resolve and analysis everything in the right order.
First we need to know what types (traits and interfaces) are available, then we need to know what lets we have, and what the input and output types of everything is.
Then we can analyse the expressions, and check that all types match up.</p><p>The resulting <code>SemanticContext</code> struct and its contents are so detailed that they can easily be resolved into a result to be displayed in the console, which is what happens in the <code>runtime</code> module.
However, ideally I&rsquo;d like to write some more modules that turn this <code>SemanticContext</code> into intermediate code, which can then be compiled into an actual binary by LLVM.</p><p>Either way, even without compiling to a binary, I feel pretty satisfied with this compiler, at the moment more of an interpreter. that can parse Compost code and execute it!
If you are interested in the Compost programming language please check out the <a href=https://github.com/sytzez/compost/>GitHub repository</a>, which contains more information about the language in the README.
And also check out the <a href=http://compost-playground.sytzez.com/>Compost Playground</a> in which you can run Compost code from your browser.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://sytzez.com/tags/programming/>programming</a></li><li><a href=https://sytzez.com/tags/compost/>compost</a></li><li><a href=https://sytzez.com/tags/rust/>rust</a></li><li><a href=https://sytzez.com/tags/compiler/>compiler</a></li></ul><nav class=paginav><a class=prev href=https://sytzez.com/blog/creating-a-compiler-for-compost-using-rust-part-2-syntactic-analysis/><span class=title>« Prev</span><br><span>Creating a Compiler for Compost using Rust, Part 2: Syntactic Analysis</span></a>
<a class=next href=https://sytzez.com/blog/how-i-manage-my-work-like-a-boss/><span class=title>Next »</span><br><span>How I manage my work like a boss</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on twitter" href="https://twitter.com/intent/tweet/?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f&hashtags=programming%2ccompost%2crust%2ccompiler"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f&title=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis&summary=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis&source=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f&title=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on whatsapp" href="https://api.whatsapp.com/send?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis%20-%20https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Creating a Compiler for Compost using Rust, Part 3: Semantic Analysis on telegram" href="https://telegram.me/share/url?text=Creating%20a%20Compiler%20for%20Compost%20using%20Rust%2c%20Part%203%3a%20Semantic%20Analysis&url=https%3a%2f%2fsytzez.com%2fblog%2fcreating-a-compiler-for-compost-using-rust-part-3-semantic-analysis%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://sytzez.com/>sytzez</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script id=mermaid-script async src=https://cdn.jsdelivr.net/npm/mermaid@9.1.7/dist/mermaid.min.js></script>
<script>document.getElementById("mermaid-script").addEventListener("load",()=>{mermaid.initialize({startOnLoad:!0,theme:"neutral"})})</script><script id=osmd-script async src=https://cdn.jsdelivr.net/npm/opensheetmusicdisplay@1.5.7/build/opensheetmusicdisplay.min.js></script>
<script>(()=>{document.addEventListener("DOMContentLoaded",t),document.getElementById("osmd-script").addEventListener("load",t);let e=!0;function t(){if(e){e=!1;return}document.querySelectorAll(".osmd-container").forEach(e=>{const t=new opensheetmusicdisplay.OpenSheetMusicDisplay(e,{drawingParameters:"compacttight"});t.load(e.dataset.musicXmlSrc).then(()=>{t.render()})})}})()</script><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>